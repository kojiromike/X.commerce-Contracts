grammar com.x.xocl.XOCL with org.eclipse.xtext.common.Terminals

generate domainmodel "http://xocl.x.com/XOCL"

DomainModel: elements += Package;

Package:
    _PACKAGE name = PackageName (VersionNumber)?
    LBRACE
        (members += PackageMember)+
    RBRACE
;

PackageName: ID (PERIOD ID)* PERIOD VERSION;

VersionNumber: FLOATVALUE;

QualifiedName: (PackageName PERIOD)? ID (PERIOD ID)*;

PackageMember:
	Import |
    Contract | 
    Entity | 
    Process | 
    NamedWorkflow | 
    Transaction | 
    NamedType
;

Import: _IMPORT importedNamespace = (WildcardImport | ElementImport);

WildcardImport: PackageName PERIOD ASTERISK?;

ElementImport: PackageName PERIOD ID;

Contract:
    _CONTRACT name = ID 
    (EXTENDS extends += [Contract | QualifiedName] (COMMA extends += [Contract | QualifiedName])*)?
    LBRACE
        DESCRIPTION description = STRING
        ROLES
    	LBRACE
    		(responsibility += Responsibility)+
    	RBRACE
    RBRACE
;

Responsibility:
	role = [ProcessRole | QualifiedName] 
	(LANGLE (variants += ProcessVariant) (COMMA variants += ProcessVariant)* RANGLE)?
	(LPAREN workflow = [Workflow | QualifiedName] RPAREN)?
;

Process:
    _PROCESS name = ID
    (LANGLE (variants += ProcessVariant) (COMMA variants += ProcessVariant)* RANGLE)?
    (LPAREN (parameters += ProcessParameter) (COMMA (parameters += ProcessParameter))* RPAREN)?
    LBRACE
        DESCRIPTION description = STRING
        ROLES LPAREN (roles += ProcessRole) (COMMA (roles += ProcessRole))+ RPAREN
    	(preconditions = PreconditionsClause)?
    	(workflow = AnonymousWorkflow)?
    	(postconditions = PostconditionsClause)?
    RBRACE
;

ProcessVariant: name = ID;

ProcessParameter: Parameter;

Parameter: type = [Entity | QualifiedName] name = ParameterName;

ParameterName: ID;

ProcessRole: Role;
 
Role: name = ID;

PreconditionsClause:
    PRECONDITIONS 
    LPAREN 
    	(conditions += BooleanExpression) 
    	(COMMA conditions += BooleanExpression)* 
	RPAREN
;

Entity:
    _ENTITY name = ID 
    (LBRACE (states += EntityState)+ RBRACE)?
;

EntityState:
    STATE name = ID 
    (LBRACK (transitions += EntityStateTransition) (COMMA transitions += EntityStateTransition)* RBRACK)?
;
 
EntityStateTransition: successor = [EntityState];

PostconditionsClause:
    POSTCONDITIONS 
    {PostconditionsClause}
    LBRACE
        (success = OnProcessSuccess)?
        (failure = OnProcessFailure)?
    RBRACE
;

OnProcessResult: OnProcessSuccess | OnProcessFailure;

OnProcessSuccess:
    SUCCESS LPAREN (conditions += BooleanExpression) (COMMA conditions += BooleanExpression)* RPAREN
;

OnProcessFailure:
    FAILURE LPAREN (conditions += BooleanExpression) (COMMA conditions += BooleanExpression)* RPAREN
;

Workflow: AnonymousWorkflow | NamedWorkflow;

AnonymousWorkflow: 
	_WORKFLOW 
	(LBRACK timeout = TimeOut RBRACK)?
	contents = WorkflowBody
;

NamedWorkflow:
    _WORKFLOW name = ID 
	(LBRACK timeout = TimeOut RBRACK)?
    IMPLEMENTS implements = [Process | QualifiedName] 
    contents = WorkflowBody
;

WorkflowBody: 
	{WorkflowBody}
    LBRACE
        (elements += WorkflowElement)*
        (elements += EndPoint)?
    RBRACE
;

EndPoint: SuccessEndpoint | FailureEndpoint;

SuccessEndpoint: name = SUCCESS;

FailureEndpoint: name = FAILURE;

WorkflowElement: DoElement | OneElement | AnyElement | AllElement | IfElement | ActionElement;

DoElement:
	DO
    (LANGLE (variants += WorkflowVariantMapping) (COMMA variants += WorkflowVariantMapping)* RANGLE)?
    (LPAREN ((count = CountExpression) | (condition = BooleanExpression)) RPAREN)?
	(LBRACK timeout = TimeOut RBRACK)?
    LBRACE
    	(elements += WorkflowElement)+
        (elements += FailureEndpoint)?
    RBRACE
;

CountExpression: lower = BoundExpression (RANGE upper = BoundExpression)?;

BoundExpression: (count = INT) | (bound ?= ASTERISK);

OneElement:
    ONE
    (LANGLE (variants += WorkflowVariantMapping) (COMMA variants += WorkflowVariantMapping)* RANGLE)?
	(LBRACK timeout = TimeOut RBRACK)?
    LBRACE
    	(elements += WorkflowElement)+
    RBRACE
;

AnyElement:
    ANY
    (LANGLE (variants += WorkflowVariantMapping) (COMMA variants += WorkflowVariantMapping)* RANGLE)?
    (LPAREN count = INT RPAREN)?
	(LBRACK timeout = TimeOut RBRACK)?
    LBRACE
    	(elements += WorkflowElement)+
        (elements += SuccessEndpoint)?
    RBRACE
;

AllElement:
    ALL
    (LANGLE (variants += WorkflowVariantMapping) (COMMA variants += WorkflowVariantMapping)* RANGLE)?
    (LBRACK timeout = TimeOut RBRACK)?
    LBRACE
    	(elements += WorkflowElement)+
        (elements += FailureEndpoint)?
    RBRACE
;

IfElement:
	{IfElement}
    IF 
    (LANGLE (variants += WorkflowVariantMapping) (COMMA variants += WorkflowVariantMapping)* RANGLE)?
    LPAREN (expression = BooleanExpression)? RPAREN
    (LBRACK timeout = TimeOut RBRACK)?
    LBRACE
        (elements += WorkflowElement)*
        (elements += EndPoint)?
    RBRACE
    (else = ElseElement)?
;

ElseElement:
	{ElseElement}
	ELSE
    (LANGLE (variants += WorkflowVariantMapping) (COMMA variants += WorkflowVariantMapping)* RANGLE)?
    (LBRACK timeout = TimeOut RBRACK)?
    LBRACE
    	(elements += WorkflowElement)*
        (elements += EndPoint)?
    RBRACE
;

BooleanExpression:
	(operator = NegationOperator leftOperand = BooleanExpression) |
	(TerminalExpression ({BinaryExpression.leftOperand=current} operator = LogicalOperator rightOperand = BooleanExpression)?)
;

NegationOperator: NOT;

LogicalOperator: AND | OR;

TerminalExpression returns BooleanExpression:
  FunctionExpression |
  LPAREN BooleanExpression RPAREN |
  ConstantExpression | 
  ParameterExpression 
;

ParameterExpression:
	value = [Parameter | QualifiedName] LBRACK state = [EntityState | QualifiedName] RBRACK
;

ConstantExpression: TrueExpression | FalseExpression;

TrueExpression: value = TRUE;

FalseExpression: value = FALSE;

FunctionExpression:
	function = FunctionName LPAREN ((arguments += FunctionArgument) (COMMA arguments += FunctionArgument)*)? RPAREN
;

FunctionArgument: 
	(expression = FunctionExpression) | 
	(parameter = [Parameter | QualifiedName])
;

// Use this rule to add function names to the language as necessary.
FunctionName: EXISTS;

ActionElement: NoopAction | TransactionCall | WorkflowCall;

NoopAction: {NoAction} NOOP;

TransactionCall:
    _TRANSACTION name = [Transaction | QualifiedName]
    (LANGLE (variants += TransactionVariantMapping) (COMMA variants += TransactionVariantMapping)* RANGLE)?
    (LPAREN (arguments += TransactionArgument) (COMMA (arguments += TransactionArgument))* RPAREN)?
    LBRACE
        ROLES LPAREN (sender = SenderRoleMapping) COMMA (receiver = ReceiverRoleMapping) RPAREN
    RBRACE
;

TransactionVariantMapping: value = [ProcessVariant | QualifiedName];

TransactionArgument: value = [ProcessParameter | QualifiedName];

SenderRoleMapping: value = [ProcessRole | QualifiedName];

ReceiverRoleMapping: value = [ProcessRole | QualifiedName];

WorkflowCall:
    _WORKFLOW name = [Workflow | QualifiedName]
    (LANGLE (variants += WorkflowVariantMapping) (COMMA variants += WorkflowVariantMapping)* RANGLE)?
    (LPAREN (arguments += WorkflowArgument) (COMMA (arguments += WorkflowArgument))* RPAREN)?
    LBRACE
        ROLES LPAREN (roles += WorkflowRoleMapping) (COMMA roles += WorkflowRoleMapping)+ RPAREN
    RBRACE
;

WorkflowArgument: value = [ProcessParameter | QualifiedName];

WorkflowVariantMapping: value = [ProcessVariant | QualifiedName];

WorkflowRoleMapping: value = ([ProcessRole | QualifiedName]);

Transaction:
    _TRANSACTION name = ID
    (LANGLE (variants += TransactionVariant) (COMMA variants += TransactionVariant)* RANGLE)?
    (LPAREN (parameters += TransactionParameter) (COMMA (parameters += TransactionParameter))* RPAREN)?
    body = (InformTransaction | NotifyTransaction | ResponseTransaction)
;

TransactionVariant: name = ID;

TransactionParameter: Parameter;

InformTransaction:
    pattern = (INFORM | INFORMATION | EVENT)
    (body = InformBody)?
;

InformBody:
    LBRACE
     	(preconditions = PreconditionsClause)?
    	SENDER sendAction = InformAction
    	(RECEIVER)?
     	(postconditions = PostconditionsClause)?
    RBRACE
;

InformAction:
    LBRACE {InformAction}
		(message = InformMessage)?
    	(variants += InformVariant)*
    RBRACE	
;

InformMessage:
	MESSAGE {InformMessage}
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = InformOptions)?	
;

InformVariant:
	MESSAGE 
	LANGLE variant = [TransactionVariant] RANGLE 
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = InformOptions)?
;

InformOptions:
	LBRACE
		requires = InformFeatures
	RBRACE
;

InformFeatures: 
    REQUIRES LPAREN (features += InformFeature) (COMMA (features += InformFeature))? RPAREN
;

InformFeature: IntegrityFeature | ConfidentialityFeature;

IntegrityFeature: integrity ?= INTEGRITY;

ConfidentialityFeature: confidentiality ?= CONFIDENTIALITY;

NotifyTransaction:
	(broadcast ?= BROADCAST)?
    pattern = (NOTIFY | NOTIFICATION)
    (body = NotifyBody)?
;

NotifyBody:
    LBRACE
     	(preconditions = PreconditionsClause)?
 		SENDER sendAction = NotifyAction
 		(RECEIVER)?
    	(postconditions = PostconditionsClause)?
    RBRACE
;

NotifyAction: 
	{NotifyAction}
    LBRACE 
    	(message = NotifyMessage)?
    	(variants += NotifyVariant)*
    RBRACE
;

NotifyMessage:
	{NotifyMessage}
	MESSAGE 
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = NotifyOptions)?
;

NotifyVariant:
	MESSAGE 
	LANGLE variant = [TransactionVariant] RANGLE 
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = NotifyOptions)?
;

NotifyOptions:
	{NotifyOptions}
	LBRACE 
		(requires = NotifyFeatures)?
		(timeouts = NotifyTimeOuts)?
		(RETRIES EQUALS retries = INT)?
	RBRACE
;

NotifyFeatures:
    REQUIRES LPAREN (features += NotifyFeature) (COMMA (features += NotifyFeature))? RPAREN
;

NotifyFeature: InformFeature | NonRepudiationFeature;

NonRepudiationFeature: nonrepudiation ?= NONREPUDIATION;

NotifyTimeOuts:
    TIMEOUTS LPAREN (timeouts += NotifyTimeOut) (COMMA (timeouts += NotifyTimeOut))? RPAREN
;

NotifyTimeOut: ReceiptAckTimeOut | ValidationAckTimeOut | RetriesTimeOut;

ReceiptAckTimeOut: RECEIPT EQUALS timeout = TimeOut;

ValidationAckTimeOut: VALIDATION EQUALS timeout = TimeOut;

RetriesTimeOut: RETRIES EQUALS timeout = TimeOut;

TimeOut: value = INT unit = TimeUnit;

TimeUnit: 
	(unit = SECONDS) | 
	(unit = MINUTES) | 
	(unit = HOURS) | 
	(unit = DAYS)
;

ResponseTransaction:
	(broadcast ?= BROADCAST)?
    pattern = Pattern
    (body = ResponseBody)?
;

Pattern:
    (pattern = RESPONSE) | (pattern = COMMAND) | 
    (pattern = QUERY)
//    (pattern = CONFIRM) | (pattern = CONFIRMATION) |
//    (pattern = OBLIGATION)
;

ResponseBody:
	{ResponseBody}
    LBRACE 
     	(preconditions = PreconditionsClause)?
 		(SENDER sendAction = SendAction)?
 		(RECEIVER receiveAction = ReceiveAction)?
    	(postconditions = PostconditionsClause)?
    RBRACE
;

SendAction: 
	{SendAction}
    LBRACE 
    	(message = SendMessage)?
    	(variants += SendVariant)*
    RBRACE
;

SendMessage:
	MESSAGE {SendMessage}
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = SendOptions)?
;

SendVariant:
	MESSAGE 
	LANGLE variant = [TransactionVariant] RANGLE 
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = SendOptions)?
;

SendOptions:
	LBRACE {SendOptions}
		(requires = SendFeatures)?
		(timeouts = SendTimeOuts)?
		(RETRIES EQUALS retries = INT)?
	RBRACE
;

SendFeatures: NotifyFeatures | AuthorizationFeature;

AuthorizationFeature: authorization ?= AUTHORIZATION;

SendTimeOuts:
    TIMEOUTS LPAREN (timeouts += SendTimeOut) ((COMMA (timeouts += SendTimeOut)) (COMMA (timeouts += SendTimeOut))?)? RPAREN
;

SendTimeOut: NotifyTimeOut | ResponseTimeOut ;

ResponseTimeOut: RESPONSE EQUALS timeout = TimeOut;

ReceiveAction:
	LBRACE {ReceiveAction}
		(success = SuccessMessage)?
    	(successVariants += SuccessVariant)*
    	(failure = FailureMessage)?
    	(failureVariants += FailureVariant)*
	RBRACE
;

SuccessMessage:
	SUCCESS {SuccessMessage}
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = NotifyOptions)?
;

SuccessVariant:
	SUCCESS 
	LANGLE variant = [TransactionVariant] RANGLE 
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = NotifyOptions)?
;

FailureMessage:
	FAILURE {FailureMessage}
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = NotifyOptions)?
;

FailureVariant:
	FAILURE 
	LANGLE variant = [TransactionVariant] RANGLE 
	(type = [RecordType | QualifiedName])?
	(topic = STRING)?
	(options = NotifyOptions)?
;

PrimitiveType:
    (name = VOID) | 
    (name = VARCHAR) |    
    (name = BOOLEAN) | 
    (name = INTEGER) | 
    (name = LONG) | 
    (name = FLOAT) | 
    (name = DOUBLE) | 
    (name = GUID) | 
    (name = DATETIME) | 
    (name = BYTES)
;

FixedType: FIXED LPAREN length = INT RPAREN;

UnionType: UNION LBRACE (members += UnionMember) (COMMA (members += UnionMember))+ RBRACE;

Member: PrimitiveType | FixedType | CollectionType | NamedTypeReference;

UnionMember: Member | NullMember;

NullMember: name = NULL;

CollectionType: MapType | ArrayType;

MapType: MAP LANGLE type = CollectionMember RANGLE;

ArrayType: ARRAY LANGLE type = CollectionMember RANGLE;

CollectionMember: Member | UnionType;

NamedTypeReference: type = [NamedType | QualifiedName];

NamedType: EnumType | RecordType;

EnumType:
	ENUM name = ID
	LBRACE
		((members += EnumLiteral)(COMMA)?)*
	RBRACE
;

EnumLiteral: ID;

RecordType:
    RECORD name = ID (EXTENDS extends = [RecordType | QualifiedName])?
    body = PropertyList
;

PropertyList: 
	{PropertyList}
    LBRACE
        ((properties += Property)(SEMICOLON)?)*
    RBRACE
;

Property: PrimitiveProperty | FixedProperty | CollectionProperty | EnumProperty | NamedTypeProperty | UnionProperty;

PropertyName: ID;

PrimitiveProperty:
    (type = VOID (optional ?= QMARK)? name = PropertyName) | 
    (type = VARCHAR (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = (STRING | NULL))?) |    
    (type = BOOLEAN (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = TRUEFALSE)?) | 
    (type = INTEGER (optional ?= QMARK)? name = PropertyName (EQUALS ndefault = INT)?) | 
    (type = LONG (optional ?= QMARK)? name = PropertyName (EQUALS ndefault = INT)?) | 
    (type = FLOAT (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = FLOATVALUE)?) | 
    (type = DOUBLE (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = FLOATVALUE)?) | 
    (type = GUID (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = (NEW | NULL))?) | 
    (type = DATETIME (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = (NOW | NULL))?) | 
    (type = BYTES (optional ?= QMARK)? name = PropertyName)
;

FixedProperty: type = FixedType (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = NULL)?;

CollectionProperty: type = CollectionType (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = NULL)?;

EnumProperty: type = [EnumType | QualifiedName] (optional ?= QMARK)? name = PropertyName EQUALS default = EnumLiteral?;

NamedTypeProperty: type = [NamedType | QualifiedName] (optional ?= QMARK)? name = PropertyName (EQUALS sdefault = NULL)?;

UnionProperty: type = UnionType (optional ?= QMARK)? name = PropertyName (EQUALS default = NULL)?;

// Terminals
terminal VERSION: 'v' ('0'..'9')+;

// Values

FLOATVALUE: INT (PERIOD INT)?;

NULL: 'null';
TRUEFALSE: 'true' | 'false';
NEW: 'new';
NOW: 'now';

// Types
ARRAY: 'array';
BOOLEAN: 'boolean';
DOUBLE: 'double';
ENUM: 'enum';
FLOAT: 'float';
INTEGER: 'int';
LONG: 'long';
MAP: 'map';
BYTES: 'bytes';
FIXED: 'fixed';
VARCHAR: 'string';
UNION: 'union';
VOID: 'void';
GUID: 'guid';
DATETIME: 'datetime';

// Keywords
EXTENDS: 'extends';
_PACKAGE: 'package';
_IMPORT: 'import';
RECORD: 'record';
_CONTRACT: 'contract';
ROLES: 'roles';
DESCRIPTION: 'description';
_PROCESS: 'process';
STATE: 'state';
POSTCONDITIONS: 'postconditions';
PRECONDITIONS: 'preconditions';
AND: '&' | '&&' | 'and';
OR: '|' | '||' | 'or';
NOT: '!' | 'not';
TRUE: 'true';
FALSE: 'false';
EXISTS: 'exists';
_ENTITY: 'entity';
SUCCESS: 'success';
FAILURE: 'failure';
DO: 'do';
ONE: 'one';
ANY: 'any';
ALL: 'all';
IF: 'if';
ELSE: 'else';
NOOP: 'noop';
MESSAGE: 'message';
TIMEOUTS: 'timeouts';
RETRIES: 'retries';
SENDER: 'sender';
RECEIVER: 'receiver';
INFORM: 'inform';
INFORMATION: 'information';
EVENT: 'event';
NOTIFY: 'notify';
NOTIFICATION: 'notification';
RESPONSE: 'response';
COMMAND: 'command';
CONFIRM: 'confirm';
CONFIRMATION: 'confirmation';
QUERY: 'query';
OBLIGATION: 'obligation';
REQUIRES: 'requires';
AUTHORIZATION: 'authorization';
IMPLEMENTS: 'implements';
NONREPUDIATION: 'nonrepudiation';
CONFIDENTIALITY: 'confidentiality';
INTEGRITY: 'integrity';
_TRANSACTION: 'transaction';
BROADCAST: 'broadcast';
AGGREGATE: 'aggregate';
_WORKFLOW: 'workflow';
RECEIPT: 'receipt';
VALIDATION: 'validation';
SECONDS: 's';
MINUTES: 'm';
HOURS: 'h';
DAYS: 'd';

// Separators
LPAREN: '(';
RPAREN: ')';
LBRACE: '{';
RBRACE: '}';
LBRACK: '[';
RBRACK: ']';
LANGLE: '<';
RANGLE: '>';
COLON:  ':';
QMARK:  '?';
SEMICOLON: ';';
COMMA: ',';
AT: '@';
EQUALS: '=';
PERIOD: '.';
ASTERISK: '*';
RANGE: '..';
